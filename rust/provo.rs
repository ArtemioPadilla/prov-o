use chrono::DateTime;
use std::sync::Arc;

// Base struct for PROV-O entities with a unique identifier
#[derive(Debug, Clone)]
struct ProvEntity {
    id: String,
}

// Core Struct: Entity - Represents something that exists or has existed
#[derive(Debug, Clone)]
struct Entity {
    base: ProvEntity,
    generated_at_time: Option<DateTime<chrono::Utc>>,  // When it was created
    invalidated_at_time: Option<DateTime<chrono::Utc>>, // When it was invalidated
    was_generated_by: Option<Arc<Activity>>,           // Activity that generated it
    was_derived_from: Option<Arc<Entity>>,             // Entity it was derived from
    was_attributed_to: Option<Arc<Agent>>,             // Agent responsible for it
    value: Option<String>,                             // Simplified value field
}

// Core Struct: Activity - Represents something that occurs over time
#[derive(Debug, Clone)]
struct Activity {
    base: ProvEntity,
    started_at_time: Option<DateTime<chrono::Utc>>, // When it started
    ended_at_time: Option<DateTime<chrono::Utc>>,   // When it ended
    was_associated_with: Option<Arc<Agent>>,        // Agent associated with it
    used: Vec<Arc<Entity>>,                         // Entities used by the activity
    generated: Vec<Arc<Entity>>,                    // Entities generated by the activity
}

// Core Struct: Agent - Represents something that bears responsibility
#[derive(Debug, Clone)]
struct Agent {
    base: ProvEntity,
    acted_on_behalf_of: Option<Arc<Agent>>,     // Agent it acted for
    was_associated_with: Vec<Arc<Activity>>,    // Activities it was associated with
    was_attributed_to: Vec<Arc<Entity>>,        // Entities attributed to it
}

// Expanded Struct: Collection - An entity that aggregates other entities
#[derive(Debug, Clone)]
struct Collection {
    entity: Entity,
    had_member: Vec<Arc<Entity>>,               // Members of the collection
}

// Expanded Struct: Person - A human agent
#[derive(Debug, Clone)]
struct Person {
    agent: Agent,
    name: Option<String>,                       // Name of the person
}

// Relationship: Derivation - A transformation of one entity into another
#[derive(Debug, Clone)]
struct Derivation {
    derived_entity: Arc<Entity>,                // The resulting entity
    source_entity: Arc<Entity>,                 // The original entity
    activity: Option<Arc<Activity>>,            // Activity that caused the derivation
}

// Specialized Relationship: WasDerivedFrom - Alias for Derivation
type WasDerivedFrom = Derivation;

// Example usage
fn main() {
    // Create an agent (a person named Alice)
    let alice = Arc::new(Person {
        agent: Agent {
            base: ProvEntity { id: "agent1".to_string() },
            acted_on_behalf_of: None,
            was_associated_with: vec![],
            was_attributed_to: vec![],
        },
        name: Some("Alice".to_string()),
    });

    // Create an activity (writing a post)
    let write_post = Arc::new(Activity {
        base: ProvEntity { id: "activity1".to_string() },
        started_at_time: Some(chrono::Utc::now()),
        ended_at_time: None,
        was_associated_with: Some(alice.clone()),
        used: vec![],
        generated: vec![],
    });

    // Create an entity (the original post)
    let original_post = Arc::new(Entity {
        base: ProvEntity { id: "post1".to_string() },
        generated_at_time: Some(chrono::Utc::now()),
        invalidated_at_time: None,
        was_generated_by: Some(write_post.clone()),
        was_derived_from: None,
        was_attributed_to: Some(alice.clone()),
        value: Some("Hello, world!".to_string()),
    });

    // Create a derived entity (a repost)
    let repost = Arc::new(Entity {
        base: ProvEntity { id: "repost1".to_string() },
        generated_at_time: Some(chrono::Utc::now()),
        invalidated_at_time: None,
        was_generated_by: Some(write_post.clone()),
        was_derived_from: Some(original_post.clone()),
        was_attributed_to: Some(alice.clone()),
        value: Some("Repost: Hello, world!".to_string()),
    });

    // Create a derivation relationship
    let derivation = WasDerivedFrom {
        derived_entity: repost.clone(),
        source_entity: original_post.clone(),
        activity: Some(write_post.clone()),
    };

    // Print the results
    println!("Original Post: {:?}", original_post);
    println!("Repost: {:?}", repost);
    println!("Derivation: {:?}", derivation);
}
